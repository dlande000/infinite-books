{"version":3,"sources":["search/SearchResult.js","search/useBookSearch.js","search/Search.js","App.js","index.js"],"names":["formatter","arr","key","length","toUpperCase","slice","join","SearchResult","title","authorName","author_name","publisher","isbn","formattedAuthorName","formattedPublisher","formattedIsbn","className","alt","src","id","useBookSearch","q","page","useState","books","setBooks","isLoading","setIsLoading","hasMoreResults","setHasMoreResults","hasError","setHasError","useEffect","cancel","axios","method","url","params","cancelToken","CancelToken","c","then","docs","data","prevBooks","concat","catch","e","isCancel","Search","query","setQuery","pageNum","setPageNum","observer","useRef","lastBookElementRef","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","prevPageNum","observe","type","value","onChange","preventDefault","target","placeholder","map","book","i","ref","Boolean","App","href","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ef6af81a.chunk.js","sourcesContent":["import React from 'react';\n\nconst formatter = (arr, key) => {\n  if (!arr) {\n    return `No ${key} provided.`;\n  }\n\n  if (arr.length === 0) {\n    return `${key[0].toUpperCase() + key.slice(1)}: ${arr[0]}`;\n  } else if (arr.length > 3) {\n    return `${key[0].toUpperCase() + key.slice(1)}s: ${arr.slice(0, 3).join(\", \")}, and ${arr.length - 3} more`;\n  } else {\n    return `${key[0].toUpperCase() + key.slice(1)}s: ${arr.join(\", \")}`;\n  }\n}\n\nconst SearchResult = ({\n  title,\n  author_name: authorName,\n  publisher,\n  isbn,\n}) => {\n  const formattedAuthorName = formatter(authorName, 'author');\n  const formattedPublisher = formatter(publisher, 'publisher');\n  const formattedIsbn = formatter(isbn, 'ISBN');\n\n  return (\n    <div className=\"box search-result\">\n      {isbn && (\n        <img\n          className=\"photo\"\n          alt={`${title} cover`}\n          src={`http://covers.openlibrary.org/b/isbn/${isbn[0]}-M.jpg`}\n        />\n      )}\n      <div className=\"book-info\">\n        <div id=\"title\">{title}</div>\n        <div>{formattedAuthorName}</div>\n        <div>{formattedPublisher}</div>\n        <div>{formattedIsbn}</div>\n      </div>\n    </div>\n  )\n}\n\nexport default SearchResult;\n","import { useState, useEffect } from 'react';\nimport axios from 'axios';\n\nconst URL = 'https://openlibrary.org/search.json';\nconst GET = 'GET';\n\nconst useBookSearch = (q, page) => {\n  const [books, setBooks] = useState([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [hasMoreResults, setHasMoreResults] = useState(false);\n  const [hasError, setHasError] = useState(false);\n\n  useEffect(() => {\n    setIsLoading(true);\n    if (hasError) setHasError(false);\n\n    let cancel;\n\n    axios({\n      method: GET,\n      url: URL,\n      params: { q, page },\n      cancelToken: new axios.CancelToken(c => cancel = c),\n    }).then(({ data: { docs }}) => {\n      setBooks(prevBooks => prevBooks.concat(docs));\n      setHasMoreResults(docs.length > 0);\n      setIsLoading(false);\n    }).catch(e => {\n      if (axios.isCancel(e)) return;\n\n      setHasError(true);\n    });\n\n    return () => cancel();\n    // eslint-disable-next-line\n  }, [q, page]);\n\n  useEffect(() => setBooks([]), [q]);\n\n  return {\n    books,\n    isLoading,\n    hasMoreResults,\n    hasError,\n  };\n};\n\nexport default useBookSearch;","import React, { useState, useRef, useCallback } from 'react';\n\nimport SearchResult from './SearchResult';\nimport useBookSearch from './useBookSearch';\n\nconst SMILE = \":)\";\n\nconst Search = () => {\n  const [query, setQuery] = useState('');\n  const [pageNum, setPageNum] = useState(1);\n  const observer = useRef();\n\n  const {\n    books,\n    isLoading,\n    hasMoreResults,\n    hasError,\n  } = useBookSearch(query, pageNum);\n\n  const lastBookElementRef = useCallback(node => {\n    if (isLoading) {\n      return;\n    } else if (observer.current) {\n      observer.current.disconnect();\n    }\n\n    observer.current = new IntersectionObserver(entries => {\n      if (entries[0].isIntersecting && hasMoreResults) {\n        setPageNum(prevPageNum => ++prevPageNum);\n      }\n    });\n\n    if (node) observer.current.observe(node);\n  }, [isLoading, hasMoreResults]);\n\n  const handleSearch = e => {\n    e.preventDefault();\n    setQuery(e.target.value);\n    setPageNum(1);\n  };\n\n  return (\n    <>\n      <input\n        type=\"text\"\n        value={query}\n        onChange={handleSearch}\n        placeholder={'Ex: Macbeth, Toni Morrison, etc.'}\n      />\n      <div id=\"results-container\">\n        {books.map((book, i) => (\n          <div\n            key={book.title + i}\n            ref={i === books.length - 1 ? lastBookElementRef : null}\n          >\n            <SearchResult {...book} />\n          </div>\n        ))}\n      </div>\n      {isLoading && (\n        <div className=\"box message\" id=\"loading\">\n          Loading . . .\n        </div>\n      )}\n      {hasError && (\n        <div className=\"box message\" id=\"error\">\n          An error has occurred. Please refresh and try again.\n        </div>\n      )}\n      {(query && !isLoading && !hasMoreResults && Boolean(books.length)) && (\n        <div className=\"box message\" id=\"no-results\">\n          <div>That's everything for:</div>\n          <div id=\"query\">{query}</div>\n          <div>Happy reading! {SMILE}</div>\n        </div>\n      )}\n      {(!query && !isLoading) && (\n        <div className=\"box message\" id=\"loading\">\n          Use the search bar to find infinite books.\n        </div>\n      )}\n      {(query && !isLoading && !books.length) && (\n        <div className=\"box message\" id=\"error\">\n          <div>No results for:</div>\n          <div id=\"query\">{query}</div>\n        </div>\n      )}\n    </>\n  );\n};\n\nexport default Search;","import React from 'react';\n\nimport Search from './search/Search';\n\nconst App = () => (\n  <div id=\"app\">\n    <h1>infinite books.</h1>\n    <div>So much to read, so little time.</div><br/>\n    <div className=\"small-text\">\n      Need an infinite list of reading material? \n      Infinite Books uses the <a href=\"https://openlibrary.org/developers/api\">Open Library API</a> to return as many books as can be found.\n      Infinite Books was built by David Anderson to experiment with React Hooks, an infinite scroll, and Anime.js. \n      The repo for this page can be found <a href='https://github.com/dlande000/infinite-books'>here</a>.\n    </div><br/>\n    <div className=\"small-text\">Happy infinite reading!</div><br/>\n    <Search/>\n  </div>\n);\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}